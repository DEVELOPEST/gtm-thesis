% TODO: Exsisting solutions comparison here?

We decided to have time tracking data stored in Git Notes for every repo so that it can be tightly tied to code.
This gives us opportunity to have more complete overview when and on what issue / branch the time was spent.
It also gives access to a features such as git diff that can be used for measuring writing speed.
Furthermore, it lifts a job from our shoulders by handling complex cases such as rebase and merge for us.

The downside is that git notes take up some space on client machine and Git server.
They can also be externally edited, and they might cause issues with git usage if developer does not follow best practices.
Nonetheless, we decided to go this way as the space used by git notes is fractional compared to file sizes, and our app is a tool for the developer,
so we don't see any urgent need to protect it from him.

We also found open source CLI app made for local time-tracking with Git, so we decided to base our app on the already existing code and add more functionality.
There is always an option to switch to external database for storing this kind of data but there is no reason to so at the moment.

Partly enforced by the usage of git, the general design is shown on Figure
\ref{fig:project-archidecture}.

\begin{figure}[h]
    \includegraphics[width=\textwidth]{figures/project_archidecture}
    \caption{Application general design}
    \label{fig:project-archidecture}
\end{figure}

The general time-tracking application can be divided into three different kind of smaller applications:
\begin{enumerate}
    \item \textbf{Applications that are responsible for data collecting.} These applications are CLI app and IDE plugins and are installed on developers machine.
    \item \textbf{Applications that are responsible for syncing data.} This role is filled by a Sync client, and these applications are installed onto companies servers where they can access git internal network.
    \item \textbf{Applications that are responsible for analyzing and displaying data.} These are Frontend and Backend app that can be installed on any public server.
\end{enumerate}

The reasoning behind this architecture is scalability and security.
For every Backend there can be multiple Sync clients all installed on different machines and with different Git access rights.
For every Sync client there can be multiple Client apps all logging time independent of one another.
And in the end, there can be multiple IDE plugins interacting with CLI app.

For security, it is very important to ensure, that no sensitive information is leaked.
To deal with this issue many companies have their Git available only in an internal network.
Not to rise any more security concerns we decided to follow the same principle and not export any git code outside internal network.
That is the reason, why Sync client is needed as it has access to internal network, but only uploads time-tracking related information to our Backend.
Therefore, actual code never leaves an internal network.

All the applications that are installed on either client machine or client server are open source so that the client can easily verify,
they only do what they are meant to do.

To properly manage numerous apps in different programming languages we decided to have each app source code in separate git repository.
This reduces the amount of merge conflicts and also makes building CI/CD easier.


\section{Client CLI app}\label{sec:cli-app}
%TODO(Tavo): We should somewhere state what are gtm-core, gtm-api, gtm-*
This is the main app on client machine.
The app is responsible for storing events sent by an editor to files and then later also combining the stored information into Git Note.
You can also see all main stats, such as time spent on a commit via CLI app.

The app is based on open source time tracking app \href{https://github.com/git-time-metric/gtm}{Git-Time-Metric} written in Go and licenced under MIT licence.
We decided to base our app on Git-Time-Metric solution because their app was working the way we wanted to, it had plenty of users meaning plenty of testing done,
and the Git-Time-Metric app had good code style.

Gtm-core folder structure is displayed in Table
\ref{tab:gtm-core-folder-structure}.

\begin{table}[h]
    \centering
    \begin{tabular}{ | p{3cm} | p{10cm} |}
        \hline
        Folder & Purpose\\
        \hline
        .github & Github related files (Workflows for CI/CD, issues and pull requests templates)\\
        \hline
        deploy & Deploying related files.
        Currently, only Windows installer files and Licence packed with installer.\\
        \hline
        command & Every command has files <command>.go and <command>\_test.go which respectively are controller for command, and it's tests.
        The controller is responsible for parsing arguments, calling appropriate services and printing out results.\\
        \hline
        docs & Documentation files.\\
        \hline
        epoch & Unix epoch helper functions and their tests.\\
        \hline
        event & Events files serialization and deserialization related services and tests.\\
        \hline
        metric & Metric file serialization, deserialization services and tests.
        Metric files are used for storing time data of files added to git, but not committed.\\
        \hline
        note & Git notes serialization, deserialization and tests.\\
        \hline
        project & Gtm initialization and uninitialization related services with tests.
        These services are responsible for calling appropriate functions from scm package to git hooks and modifying git config.\\
        \hline
        report & Report generation services used by report command.\\
        \hline
        scm & Git related services.
        These services are used to wrap libgit2-go services into more usable form.\\
        \hline
        test & Python files for running stress tests for gtm-core.\\
        \hline
        util & Various string, datetime and math helper functions.\\
        \hline
        vendor & Directory containing dependencies listed in git submodules.\\
        \hline
        <root> & Program entry point, git related files, README and gofmt style lint configuration .\\
        \hline
    \end{tabular}
    \caption{Gtm-core folder structure.}
    \label{tab:gtm-core-folder-structure}
\end{table}

Although the app was already working we still needed to do many bug fixes and add some features it didn't have.
The biggest change in design was that we removed copied in dependencies to git submodules.
Although this seems like a small step it turned out to be very complex to build go linked with C library dynamically.
As we didn't manage to get on dependency to properly work in Windows environments we decided to leave it separately fetched and built in ci/cd workflow file.
Nonetheless, all "snapshot" dependencies were removed.
We also added stress tests to verify effect of using gtm-core with large amounts of commits.

\section{IDE plugins}\label{sec:ide-plugins}
IDE plugins installed on developer IDE, and they execute CLI app commands on specific editor events.
Plugins are needed to listen for editor events such as typing without having to give CLI app extensive permissions to run in background.
They also provide a simple way to display some information in IDE.
For example time since last commit is show to user inside IDE.

Currently, we only have one plugin that is compatible with all Jetbrains IDE's.
The gtm-jetbrains plugin is written in Kotlin and uploaded to Jetbrains plugin repository so that you can easily install it in your Jetbrains IDE.
Kotlin was chosen as the plugin was limited to JVM based language and only Java and Kotlin were widely supported.
We have experience in both Java and Kotlin, but we both preferred Kotlin to Java due to its null safety and functional patterns.

Gtm-jetbrains folder structure is described in Table
\ref{tab:gtm-jetbrains-folder-structure}.
Namespace ee.developest.gtm is shortened to <ns> for readability.

\begin{table}[h]
    \centering
    \begin{tabular}{ | p{3cm} | p{10cm} |}
        \hline
        Folder & Purpose\\
        \hline
        .gradle & Gradle related files\\
        \hline
        src/<ns>/listener & Editor event listeners.\\
        \hline
        src/<ns>/popup & Popups related controllers.
        Used for getting user input\\
        \hline
        src/<ns>/service & Service files such as ConfigService.kt\\
        \hline
        src/<ns>/widget & Widget factories used to display time since last commit and some feedback about initialization.\\
        \hline
        src/<ns> & Gtm-core wrapper used to forward commands from listeners to gtm-core and gtm-core to popup / widget.\\
        \hline
        <root> & Gradle configuration, README and LICENCE.\\
        \hline
    \end{tabular}
    \caption{Gtm-core folder structure.}
    \label{tab:gtm-jetbrains-folder-structure}
\end{table}

\section{Sync client}\label{sec:sync-client}
Sync client is run on a network, where it can access git repositories.
On git push, hook sends request to gtm-sync via HTTP request.
Then gtm-sync fetches git repository with its time data, extracts required data and syncs it up to Backend.

The gtm-sync application was written in Rust as it had more up to date library for libgit2 than both Java and Go, required for interacting with git.
Although we did not have prior experience with Rust we preferred it to C/C++ as it is memory safe and it has higher level libraries that can be
used for building a web server and API client.
Python and NodeJS were ruled out because they produce very big memory footprint compared to Rust, and they also run a lot slower.
Neither of them also gives a type safety that was a must for us.

For the code design, we followed domain based architecture.
Folder structure for gtm-sync is displayed in Table
\ref{tab:gtm-sync-folder-structure}.

\begin{table}[h]
    \centering
    \begin{tabular}{ | p{3cm} | p{10cm} |}
        \hline
        Folder & Purpose\\
        \hline
        .github & Github workflows.\\
        \hline
        src/config & Config serialization, deserialization and config helper functions.\\
        \hline
        src/gtm & Gtm notes parsing and git related services.\\
        \hline
        src/repo & Tracked repository managing services.\\
        \hline
        src/server & Rocket controllers used for IO.\\
        \hline
        src/sync & Syncing data with gtm-api related services.\\
        \hline
        <root> & Git related files, Cargo package manager files, README and LICENCE.\\
        \hline
    \end{tabular}
    \caption{Gtm-sync folder structure.}
    \label{tab:gtm-sync-folder-structure}
\end{table}

\section{Backend}\label{sec:backend}
Back-end is a collection of code which runs on the server.
It receives requests from clients and sends appropriate data back to the clients based on the business logic.
Back-end also has a database which stores all the necessary data for the application.
% TODO: Some info about db

In our case back-end receives data from sync client via REST API requests and stores the data in the database.
End users can only fetch necessary data via REST API requests and back-end application provides appropriate data to the clients.

% TODO: More explanation
Back-end application has been built with Rust using Rocket framework.
Since Rust is a low-level statically-typed multi-paradigm programming language that's focused on performance and safety, it overweighted Java, Python, NodeJS, C\# and C/C++.

% TODO: More explanation
Back-end code base has been built following DDD because it helps to keep application maintainable, extendable and organized.
DDD has been around over 17 years and means that the code structure should match the business domain.

% TODO Folder structure


\section{Frontend}\label{sec:frontend}
The frontend of a software program or website is everything with which the user interacts.
From a user standpoint, the frontend is synonymous with the user interface.
From a developer standpoint, it is the interface design and the programming that makes the interface function.
One of the primary goals of frontend development is to create a smooth or "frictionless" user experience.
In other words, the front end of an application or website should be intuitive and easy to use.

Frontend has been built with Javascript using React JS framework as React JS is the most widely used frontend framework.
React is a lightweight framework unlike others like Angular or Ember.
React provides a component based structure which means components are like lego pieces which can be reused.
%TODO: Some actual comaprison

% TODO: Folder structure